/*
    JUnit은 각 테스트에 대해 객체를 만들어 독립적으로 실행한다는 개념을 생각해두셔야 합니다.

    @BeforeAll과 @BeforeEach의 차이와 각각의 메서드가 static이냐 아니냐의 이유는 JUnit의 테스트 실행 방식과 밀접하게 관련이 있습니다.

1. @BeforeAll이 static이어야 하는 이유

	•	테스트 클래스의 인스턴스가 생성되기 전에 실행됨:
	•	JUnit은 테스트를 실행하기 위해 테스트 클래스의 인스턴스를 생성합니다.
	•	@BeforeAll은 테스트 클래스의 모든 테스트 메서드가 실행되기 전에 한 번만 실행되므로, 테스트 클래스의 인스턴스가 생성되기 전인 **정적 컨텍스트(static context)**에서 실행될 필요가 있습니다.
	•	객체가 생성되지 않은 상태에서 실행 가능해야 함:
	•	테스트 클래스의 인스턴스와 관계없이 실행되므로, 테스트 메서드들이 속한 클래스의 상태에 의존하지 않아야 합니다.
	•	따라서 static으로 선언해야 합니다.

2. @BeforeEach가 static이 아닌 이유

	•	테스트 클래스의 인스턴스가 생성된 후 실행됨:
	•	@BeforeEach는 각 테스트 메서드 실행 전에 호출됩니다.
	•	JUnit은 각 테스트 메서드를 실행하기 전에 테스트 클래스의 인스턴스를 새로 생성합니다. 이 때문에 @BeforeEach 메서드는 테스트 클래스의 인스턴스 메서드로 선언됩니다.
	•	인스턴스 상태 초기화 가능:
	•	@BeforeEach는 각 테스트 메서드마다 새로운 객체를 초기화하는 데 유용합니다.
	•	테스트 메서드가 실행되기 전에 테스트 클래스의 상태를 새로 설정하거나 초기화하는 작업에 사용되므로, 정적 메서드가 아닌 인스턴스 메서드로 작성됩니다.

요약

	•	@BeforeAll은 클래스 수준에서 동작하므로 static이어야 합니다.
	•	@BeforeEach는 테스트 메서드 수준에서 동작하며, 각 테스트 실행 전에 객체의 상태를 설정할 수 있어야 하므로 static일 필요가 없습니다.

이 설계는 JUnit이 테스트 격리를 보장하기 위한 구조적 선택입니다. 매 테스트 메서드 실행마다 객체를 새로 생성하여 다른 테스트에 영향을 주지 않도록 하는 것이 JUnit의 철학 중 하나입니다.

맞습니다! @AfterAll이 static이어야 하는 이유는 아래와 같이 설명할 수 있습니다:

1. @AfterAll은 테스트 클래스의 모든 테스트가 실행된 후 1회 실행됨

	•	JUnit의 테스트 실행 방식:
	•	JUnit은 각 @Test 메서드 실행 전에 테스트 클래스의 객체를 새로 생성합니다.
	•	@AfterAll은 모든 테스트 메서드가 실행된 후 마지막에 한 번만 실행됩니다.
	•	이 시점에는 각 테스트 메서드를 위해 생성된 테스트 클래스의 인스턴스가 이미 삭제되었거나 더 이상 사용되지 않습니다.

2. 객체와 무관하게 실행되어야 함

	•	@AfterAll은 클래스 전체와 관련된 **정리 작업(cleanup)**을 수행하기 위한 메서드입니다.
	•	테스트 클래스의 객체 상태에 의존하지 않아야 하며, 특정 객체 없이 실행 가능해야 합니다.
	•	따라서, @AfterAll 메서드는 **클래스 수준의 정적 컨텍스트(static context)**에서 실행되어야 합니다.

3. 테스트 인스턴스가 더 이상 존재하지 않음

	•	모든 @Test 메서드가 실행된 이후, 테스트 프레임워크는 테스트 클래스의 인스턴스를 유지하지 않습니다.
	•	따라서, 객체가 없는 상태에서도 실행할 수 있도록 static으로 선언해야 합니다.

요약

	•	@AfterAll은 클래스 수준에서 동작하며, 모든 테스트 메서드가 실행된 후 객체와 무관하게 실행되는 마지막 정리 작업을 담당합니다.
	•	테스트 객체는 각 @Test 메서드 실행 후 생성 및 파괴되므로, @AfterAll 메서드는 객체가 없는 상태에서도 실행 가능하도록 static으로 선언되어야 합니다.

이 설계는 JUnit이 테스트 간 독립성을 보장하고, 테스트 클래스의 상태에 의존하지 않는 구조를 유지하도록 돕습니다.
 */

import org.junit.jupiter.api.*;

public class JUnitCycleTest {

    @BeforeAll // 전체 테스트를 시작하기 전에 1회 실행하므로 메서드는 static으로 선언 -> 즉 객체 생성 전
    static void beforeAll() {
        System.out.println("@BeforeAll");
    }

    @BeforeEach // 테스트 케이스를 시작하기 전마다 실행
    public void beforeEach() {
        System.out.println("@BeforeEach");
    }

    @Test
    public void test1() {
        System.out.println("test1");
    }

    @Test
    public void test2() {
        System.out.println("test2");
    }

    @Test
    public void test3() {
        System.out.println("test3");
    }

    @AfterAll // 전체 테스트를 마치고 종료하기 전에 1회 실행하므로 메서드는 static으로 선언
    static void afterAll() {
        System.out.println("@AfterAll");
    }

    @AfterEach // 테스트 케이스를 종료하기 전마다 실행
    public void afterEach() {
        System.out.println("@AfterEach");
    }
}

/*
    @BeforeAll
        전체 테스트를 시작하기 전에 처음으로 한 번만 실행.
        예를 들어 데이터베이스를 연결해야 하거나 테스트 환경을 초기화할 때 사용
        실행 주기에서 한 번만 호출되어야 하기 때문에 메서드를 static으로 선언해야 함.

    @BeforeEach
        테스트 케이스를 시작하기 전에 매번 실행.
        예를 들어 테스트 메서드에서 사용하는 객체를 초기화하거나 테스트에 필요한 값을 미리 넣을 때 사용할 수 있음.
        각 인스턴스에 대해 메서드를 호출해야 하므로 메서드는 static이 아니어야 함.

    @AfterAll
        전체 테스트를 마치고 종료하기 전에 한 번만 실행/
        예를 들어 데이터베이스 연결을 종료할 때나 공통적으로 사용하는 자원을 해제할 때 사용 가능
        전체 테스트 실행 주기에서 한 번만 호출되어야 하므로 메서드를 static으로 선언해야 함.

    @AfterEach
        각 테스트 케이스를 종료하기 전 매번 실행함. 예를 들어 테스트 이후에 특정 데이터를 삭제해야 하는 경우 사용.

     05 단계로 넘어감. -> 테스트 코드를 실행해서 출력 결과를 확인 -> SpringBootDeveloperApplication 확인
 */
